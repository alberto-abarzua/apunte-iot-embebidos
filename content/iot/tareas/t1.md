---
title: "T1"
description: ""
date: 2023-08-10T14:57:13Z
lastmod: 2023-08-10T14:57:13Z
draft: false
images: []
weight: 10
---

_Universidad de Chile_
_Facultad de Ciencias Físicas y Matemáticas Departamento de Ciencias de la computacion_ 
_CC5326 – Diseño de Internet de las Cosas_

--- 

**Profesor:** Luciano Radrigan F.
**Auxiliar:** Alberto Abarzua P.

Cada equipo contara con una Raspberry Pi3 y dos ESP-32

Objetivos a cumplir

- [ ]  A través de la Raspberry generar una red WiFi (con nombre y contraseña)
- [ ]  En la Raspberry programar un socket TCP y UDP server
- [ ]  En el ESP32 programar un socket TCP y UDP client
- [ ]  Se enviara un paquete desde ESP32 con datos generados dentro de la misma, el cual el servior
- [ ] Guardar la informacion en una base de datos


## Headers de los paquetes

Cada paquete debe tener su propio header, el cual debe contener la siguiente información, este sera común para todos los protocolos de envio:


| Header    | Data                                        |
|-----------|---------------------------------------------|
| 2 bytes   | ID                                          |
| 6 bytes   | Device MAC                                  |
| 1 byte    | Transport Layer                             |
| 1 byte    | ID Protocol                                 |
| 2 bytes   | Length                                      |


• Los protocolos de envio que deberán probar son:
Tabla 2: Protocolos 0,1,2 y 3 .

|                     | Size|     1 bytes     |     1 bytes        |     4 bytes       |     1 bytes     |     4 bytes     |     1 bytes     |     4 bytes     |     8000 bytes     |     8000 bytes     |     8000 bytes    |
|---------------------|--------------------------------|-----------------|--------------------|-------------------|-----------------|-----------------|-----------------|-----------------|--------------------|--------------------|-------------------|
|     ID protocol     |     Leng msg (bytes)           |     Data 1      |     Data 2         |     Data 3        |     Data 4      |     Data 5      |     Data 6      |     Data 7      |     Data 8         |     Data 9         |     Data 10       |
|     4               |     24016                      |     Val: 1      |     Batt Level     |     Timestamp     |     Temp        |     Press       |     Hum         |     Co          |     Acc X          |     Acc y          |     Acc z         |          |



|     Tamaño de los datos ->     |     Len (Body)    |        24016       |
|--------------------------------|-------------------|:------------------:|
|     1 bytes                    |     Data 1        |     Val: 1         |
|     1 bytes                    |     Data 2        |     Batt Level     |
|     4 bytes                    |     Data 3        |     Timestamp      |
|     1 bytes                    |     Data 4        |     Temp           |
|     4 bytes                    |     Data 5        |     Press          |
|     1 bytes                    |     Data 6        |     Hum            |
|     4 bytes                    |     Data 7        |     Co             |
|     8000 bytes                 |     Data 8        |     Acc X          |
|     8000 bytes                 |     Data 9        |     Acc y          |
|     8000 bytes                 |     Data 10       |     Acc z          |
Tarea 1 1

Indicaciones
Flujo de datos
1. Microcontrolador inicia a través de conexión TCP
2. Realiza una consulta a la base de datos sobre valor de la variable ID_protocol y T ransport_Layer,
con las cuales sabrá cual protocolo de paquete y tipo de conexión (TCP o UDP) deberá trabajar.
3. Con esto obtenido realizara el envió de paquetes con lo indicado, con la siguiente especificación:
• En caso de usar TCP: enviara el paquete de datos y entrara en modo DeepSleep por 60
segundos, tras lo cual repetirá el proceso.
• En caso de usar UDP: Se enviara los datos sin para hasta que el valor de T ransport_Layer
cambie, este deberá poder ser cambiado manualmente (por ejemplo apretando un botón).
4. Los paquetes recibidos por la Raspberry deberán ser abiertos y guardados dentro de una base
de datos SQL.
5. Si desea puede programar un mecanismo para que el envió de datos se detenga completamente,
apretando un botón por ejemplo.
Base de datos
La base de datos (se recomienda usar MySQL para el manejo de esta) debe contener las siguientes
tablas:
• Datos: Esta tabla tendrá todos los datos recibidos con su timestamp y el identificador del
dispositivo (Id_device y MAC).
• Logs: Esta tabla tendrá la información de cada conexión que haya recibido el servidor, teniendo
el ID device, el tipo de transport layer, cual protocolo y timestamp de este.
• Configuración: Esta tabla contendrá las variables ID_protocol y T ransport_Layer con las
cuales se configurara el envió de datos al iniciar la conexión de la ESP32. Estos deben poder
cambiarse de alguna forma.
• Loss: Esta tabla contendrá el tiempo de demora de comunicación (tiempo desde el momento
de envio hasta el momento de escritura en la base de datos, calcúlese usando la diferencia entre
esos timestamps) y la cantidad de packet loss (bytes perdidos) de cada comunicación que haya.
Generación de datos
Para generar los datos deberá implementar funciones que emulen el funcionamiento de los sensores,
usando las siguientes indicaciones (estos deben acomodar a su tamaño dentro del paquete, trunque
el valor de ser necesario):
• Acceloremeter_Sensor: Un medidor de aceleración para este se generara un vector de 2000
datos por eje. Estos serán floats generados por la siguiente formula (n es un número cualquiera,
deben ser distintos entre datos del mismo eje):
– Accx = 2 · sin(2π · 0.001 · n)
– Accy = 3 · cos(2π · 0.001 · n)
– Accz = 10 · sin(2π · 0.001 · n)
Tarea 1 2

• THPC_Sensor (Temperatura-Humedad-Presión-CO2): representa un sensor de cada uno de
estos aspectos, genere su medición usando los siguientes valores:
– T emp = Valor aletorio entre 5 y 30
– Hum = Valor aletorio entre 30.0 a 80.0
– P res = Valor aletorio entre 1000 y 1200
– CO2 = Valor aletorio entre 30.0 y 200.0
• Batt_sensor: representando el nivel de bateria del aparato, debera ser un valor entre 1 y 100.
• Acelerometer_kpi: representa un sensor de vibraciones, midiendo en los tres ejes y sacando
su promedio (RMS, root mean square), para sus valores use:
– Ampx = valor aletorio entre 0.0059 y 0.12
– F recx = valor aletorio entre 29.0 y 31.0
– Ampy = valor aletorio entre 0.0041 y 0.11
– F recy = valor aletorio entre 59.0 y 61.0
– Ampz = valor aletorio entre 0.008 y 0.15
– F recz = valor aletorio entre 89.0 y 91.0
– RMS =
q
(Amp2
x + Amp2
y + Amp2
z
)

## Entrega

1. Una demostración en vivo del funcionamiento del sistema, el dia **[Fecha por confirmar en U-cursos]**

2. Subir el código a U-cursos (misma fecha de entrega que la demostración). De ser posible entregue un link a un repositorio Git donde se trabajo la tarea.
